<!DOCTYPE html>
<html>
<head>
    <title>AR View</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://raw.githack.com/jeromeetienne/AR.js/master/three.js/build/ar.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/r128/examples/js/loaders/MTLLoader.js"></script>
    <script src="https://raw.githack.com/mrdoob/three.js/r128/examples/js/loaders/OBJLoader.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body style='margin : 0px; overflow: hidden;'>

<script>
    var scene, camera, renderer, clock, deltaTime, totalTime;
    var arToolkitSource, arToolkitContext;
    var markerRoot;

    function initialize() {
        scene = new THREE.Scene();
        let ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
        scene.add(ambientLight);

        camera = new THREE.Camera();
        scene.add(camera);

        renderer = new THREE.WebGLRenderer({
            antialias: true,
            alpha: true
        });
        renderer.setClearColor(new THREE.Color('lightgrey'), 0);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = 'absolute';
        renderer.domElement.style.top = '0px';
        renderer.domElement.style.left = '0px';
        document.body.appendChild(renderer.domElement);

        clock = new THREE.Clock();
        deltaTime = 0;
        totalTime = 0;

        arToolkitSource = new THREEx.ArToolkitSource({
            sourceType: 'webcam',
        });

        function onResize() {
            arToolkitSource.onResizeElement();
            arToolkitSource.copyElementSizeTo(renderer.domElement);
            if (arToolkitContext.arController !== null) {
                arToolkitSource.copyElementSizeTo(arToolkitContext.arController.canvas);
            }
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        }

        arToolkitSource.init(function onReady() {
            onResize();
        });

        window.addEventListener('resize', function () {
            onResize();
        });

        arToolkitContext = new THREEx.ArToolkitContext({
            cameraParametersUrl: 'data/camera_para.dat',
            detectionMode: 'mono',
        });

        arToolkitContext.init(function onCompleted() {
            camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix());
        });

        markerRoot = new THREE.Group();
        scene.add(markerRoot);

        const urlParams = new URLSearchParams(window.location.search);
        const productId = parseInt(urlParams.get('productId'));

        fetch('products.json')
            .then(response => response.json())
            .then(products => {
                const product = products.find(p => p.id === productId);
                if (product) {
                    let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                        type: product.marker_type,
                        patternUrl: product.marker_url,
                    });

                    function onProgress(xhr) { console.log((xhr.loaded / xhr.total * 100) + '% loaded'); }
                    function onError(xhr) { console.log('An error happened'); }

                    new THREE.MTLLoader()
                        .setPath('models/')
                        .load(product.material_url.split('/').pop(), function (materials) {
                            materials.preload();
                            new THREE.OBJLoader()
                                .setMaterials(materials)
                                .setPath('models/')
                                .load(product.model_url.split('/').pop(), function (group) {
                                    const mesh = group.children[0];
                                    mesh.material.side = THREE.DoubleSide;
                                    const position = product.position.split(' ').map(Number);
                                    mesh.position.set(position[0], position[1], position[2]);
                                    const scale = product.scale.split(' ').map(Number);
                                    mesh.scale.set(scale[0], scale[1], scale[2]);
                                    markerRoot.add(mesh);
                                }, onProgress, onError);
                        });
                }
            });
    }

    function update() {
        if (arToolkitSource.ready !== false) {
            arToolkitContext.update(arToolkitSource.domElement);
        }
    }

    function render() {
        renderer.render(scene, camera);
    }

    function animate() {
        requestAnimationFrame(animate);
        deltaTime = clock.getDelta();
        totalTime += deltaTime;
        update();
        render();
    }

    initialize();
    animate();

</script>

</body>
</html>