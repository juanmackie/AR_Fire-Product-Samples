<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <title>AR OBJ Model Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: "Inter", sans-serif;
            /* AR.js handles the background and display, so these are less critical for the canvas */
            background-color: #1a202c; /* Dark background for overall page, before webcam feed */
            color: #e2e8f0; /* Light text */
        }
        /* AR.js will create a canvas element, and we let it manage its size and position */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .controls-container {
            position: absolute; /* Position controls over the AR scene */
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10; /* Ensure controls are above the canvas */
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 1rem;
            align-items: center;
            width: 100%;
            max-width: 600px;
            background-color: rgba(26, 32, 44, 0.8); /* Semi-transparent dark background */
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        select {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            background-color: #4a5568;
            color: #e2e8f0;
            border: 1px solid #718096;
            cursor: pointer;
            width: 100%;
            max-width: 300px;
        }
        select:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(99, 179, 237, 0.5); /* Blue glow */
        }
        #loading-message {
            text-align: center;
            padding: 0.5rem;
        }
    </style>
</head>
<body>

    <div class="controls-container">
        <h1 class="text-3xl font-bold mb-4">AR 3D Model Viewer</h1>
        <label for="model-select" class="text-lg">Select a Model (reloads AR):</label>
        <select id="model-select" class="shadow-lg">
            </select>
        <div id="loading-message" class="text-yellow-400 mt-2 hidden">Loading model...</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-obj-loader@1.1.3/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-mtl-loader@1.0.2/index.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/artoolkit.min.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/aframe/build/artoolkit.api.js"></script>
    <script src="https://raw.githack.com/AR-js-org/AR.js/master/three.js/build/ar.js"></script>

    <script>
        // Global variables for Three.js and AR.js
        let scene, camera, renderer, clock, deltaTime, totalTime;
        let arToolkitSource, arToolkitContext;
        let markerRoot; // This will hold our AR marker and the loaded model
        let currentModel = null;
        const loadingMessage = document.getElementById('loading-message');

        // Define your OBJ models here.
        // Ensure 'models/' directory exists and contains 'fish-2.obj' and 'fish-2.mtl'.
        // For other models, add their paths similarly.
        const models = {
            'fish-2': { obj: 'models/fish-2.obj', mtl: 'models/fish-2.mtl', scale: 0.25, offsetY: 0.25 },
            // Add more models here, e.g.:
            // 'another-model': { obj: 'path/to/another-model.obj', mtl: 'path/to/another-model.mtl', scale: 1, offsetY: 0 },
        };

        // Initialize the 3D AR scene
        function init() {
            // Scene setup (AR.js manages camera)
            scene = new THREE.Scene(); [cite: 4]

            let ambientLight = new THREE.AmbientLight(0xcccccc, 1.0); [cite: 4]
            scene.add(ambientLight); [cite: 4]

            // Camera is handled by AR.js
            camera = new THREE.Camera(); [cite: 4]
            scene.add(camera); [cite: 4]

            // Renderer setup
            renderer = new THREE.WebGLRenderer({
                antialias: true, [cite: 5]
                alpha: true // Important for transparency over the webcam feed 
            });
            renderer.setClearColor(new THREE.Color('lightgrey'), 0); [cite: 5]
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.domElement.style.position = 'absolute'; [cite: 6]
            renderer.domElement.style.top = '0px'; [cite: 6]
            renderer.domElement.style.left = '0px'; [cite: 6]
            document.body.appendChild(renderer.domElement); [cite: 6]

            clock = new THREE.Clock(); [cite: 3]
            deltaTime = 0; [cite: 3]
            totalTime = 0; [cite: 3]

            // AR.js Source (webcam)
            arToolkitSource = new THREEx.ArToolkitSource({
                sourceType: 'webcam', [cite: 7]
            });

            arToolkitSource.init(function onReady() { [cite: 7]
                onResize(); [cite: 7]
            });

            window.addEventListener('resize', onResize); [cite: 8]

            // AR.js Context
            arToolkitContext = new THREEx.ArToolkitContext({
                cameraParametersUrl: 'data/camera_para.dat', // You need this file in a 'data' folder 
                detectionMode: 'mono' [cite: 9]
            });

            arToolkitContext.init(function onCompleted() { [cite: 9]
                camera.projectionMatrix.copy(arToolkitContext.getProjectionMatrix()); [cite: 9]
            });

            // AR Marker Root
            markerRoot = new THREE.Group(); [cite: 10]
            scene.add(markerRoot); [cite: 10]
            let markerControls = new THREEx.ArMarkerControls(arToolkitContext, markerRoot, {
                type: 'pattern', [cite: 10]
                patternUrl: "data/hiro.patt", // You need this file in a 'data' folder 
                changeMatrixMode: 'cameraTransformMatrix' // Ensures model stays with marker
            });

            // Populate the dropdown and load the default model
            populateModelDropdown();
            loadModel('fish-2'); // Load default model on startup
        }

        // Handle window resize events
        function onResize() {
            arToolkitSource.onResize(); [cite: 7]
            arToolkitSource.copySizeTo(renderer.domElement); [cite: 7]
            if (arToolkitContext.arController !== null) {
                arToolkitSource.copySizeTo(arToolkitContext.arController.canvas); [cite: 7]
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate); [cite: 16]
            deltaTime = clock.getDelta(); [cite: 16]
            totalTime += deltaTime; [cite: 16]
            update(); [cite: 16]
            render(); [cite: 16]
        }

        // Update AR.js context
        function update() {
            if (arToolkitSource.ready !== false) {
                arToolkitContext.update(arToolkitSource.domElement); [cite: 15]
            }
        }

        // Render the scene
        function render() {
            renderer.render(scene, camera); [cite: 16]
        }

        // Function to load an OBJ model into the markerRoot
        function loadModel(modelName) {
            // Remove previous model from the marker root
            if (currentModel) {
                markerRoot.remove(currentModel);
                currentModel.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material.map) child.material.map.dispose();
                        child.material.dispose();
                    }
                });
                currentModel = null;
            }

            loadingMessage.classList.remove('hidden'); // Show loading message

            const modelInfo = models[modelName];
            if (!modelInfo) {
                console.error(`Model "${modelName}" not found in configurations.`);
                loadingMessage.classList.add('hidden');
                return;
            }

            const objLoader = new THREE.OBJLoader();
            const mtlLoader = new THREE.MTLLoader();

            mtlLoader.setPath(modelInfo.mtl.substring(0, modelInfo.mtl.lastIndexOf('/') + 1)); [cite: 14]
            objLoader.setPath(modelInfo.obj.substring(0, modelInfo.obj.lastIndexOf('/') + 1)); [cite: 14]

            mtlLoader.load(modelInfo.mtl, function (materials) { [cite: 14]
                materials.preload(); [cite: 14]
                objLoader.setMaterials(materials); [cite: 14]

                objLoader.load(modelInfo.obj, function (object) { [cite: 14]
                    currentModel = object;

                    const scaleFactor = modelInfo.scale || 1;
                    currentModel.scale.set(scaleFactor, scaleFactor, scaleFactor); [cite: 14]

                    // Center the model and apply offset
                    const box = new THREE.Box3().setFromObject(currentModel);
                    const center = box.getCenter(new THREE.Vector3());
                    currentModel.position.sub(center); // Move model so its center is at (0,0,0) relative to its parent
                    currentModel.position.y += modelInfo.offsetY || 0; // Apply custom Y offset 

                    markerRoot.add(currentModel); [cite: 14]
                    loadingMessage.classList.add('hidden'); // Hide loading message

                }, onProgress, onError); [cite: 14]
            }, onProgress, onError); [cite: 14]
        }

        // Progress handler
        function onProgress(xhr) {
            if (xhr.lengthComputable) {
                const percentComplete = xhr.loaded / xhr.total * 100; [cite: 13]
                loadingMessage.textContent = `Loading model: ${Math.round(percentComplete)}% loaded...`;
            }
        }

        // Error handler
        function onError(error) {
            console.error('An error occurred loading the model:', error); [cite: 14]
            loadingMessage.textContent = 'Error loading model.';
            loadingMessage.classList.remove('hidden');
        }

        // Populate the model dropdown
        function populateModelDropdown() {
            const modelSelect = document.getElementById('model-select');
            for (const key in models) {
                if (models.hasOwnProperty(key)) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = key.replace(/-/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
                    modelSelect.appendChild(option);
                }
            }
            modelSelect.addEventListener('change', (event) => {
                // When changing models in AR, it's often simpler to reinitialize or at least reload the model
                // For this example, we just call loadModel again.
                loadModel(event.target.value);
            });
        }

        // Initialize the app when the window loads
        window.onload = function() {
            init();
            animate();
        };
    </script>
</body>
</html>
